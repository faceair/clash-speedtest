package ip

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

var countryFlags = map[string]string{
	"US": "ğŸ‡ºğŸ‡¸", "CN": "ğŸ‡¨ğŸ‡³", "GB": "ğŸ‡¬ğŸ‡§", "UK": "ğŸ‡¬ğŸ‡§", "JP": "ğŸ‡¯ğŸ‡µ", "DE": "ğŸ‡©ğŸ‡ª", "FR": "ğŸ‡«ğŸ‡·", "RU": "ğŸ‡·ğŸ‡º",
	"SG": "ğŸ‡¸ğŸ‡¬", "HK": "ğŸ‡­ğŸ‡°", "TW": "ğŸ‡¨ğŸ‡³", "KR": "ğŸ‡°ğŸ‡·", "CA": "ğŸ‡¨ğŸ‡¦", "AU": "ğŸ‡¦ğŸ‡º", "NL": "ğŸ‡³ğŸ‡±", "IT": "ğŸ‡®ğŸ‡¹",
	"ES": "ğŸ‡ªğŸ‡¸", "SE": "ğŸ‡¸ğŸ‡ª", "NO": "ğŸ‡³ğŸ‡´", "DK": "ğŸ‡©ğŸ‡°", "FI": "ğŸ‡«ğŸ‡®", "CH": "ğŸ‡¨ğŸ‡­", "AT": "ğŸ‡¦ğŸ‡¹", "BE": "ğŸ‡§ğŸ‡ª",
	"BR": "ğŸ‡§ğŸ‡·", "IN": "ğŸ‡®ğŸ‡³", "TH": "ğŸ‡¹ğŸ‡­", "MY": "ğŸ‡²ğŸ‡¾", "VN": "ğŸ‡»ğŸ‡³", "PH": "ğŸ‡µğŸ‡­", "ID": "ğŸ‡®ğŸ‡©", "UA": "ğŸ‡ºğŸ‡¦",
	"TR": "ğŸ‡¹ğŸ‡·", "IL": "ğŸ‡®ğŸ‡±", "AE": "ğŸ‡¦ğŸ‡ª", "SA": "ğŸ‡¸ğŸ‡¦", "EG": "ğŸ‡ªğŸ‡¬", "ZA": "ğŸ‡¿ğŸ‡¦", "NG": "ğŸ‡³ğŸ‡¬", "KE": "ğŸ‡°ğŸ‡ª",
	"RO": "ğŸ‡·ğŸ‡´", "PL": "ğŸ‡µğŸ‡±", "CZ": "ğŸ‡¨ğŸ‡¿", "HU": "ğŸ‡­ğŸ‡º", "BG": "ğŸ‡§ğŸ‡¬", "HR": "ğŸ‡­ğŸ‡·", "SI": "ğŸ‡¸ğŸ‡®", "SK": "ğŸ‡¸ğŸ‡°",
	"LT": "ğŸ‡±ğŸ‡¹", "LV": "ğŸ‡±ğŸ‡»", "EE": "ğŸ‡ªğŸ‡ª", "PT": "ğŸ‡µğŸ‡¹", "GR": "ğŸ‡¬ğŸ‡·", "IE": "ğŸ‡®ğŸ‡ª", "LU": "ğŸ‡±ğŸ‡º", "MT": "ğŸ‡²ğŸ‡¹",
	"CY": "ğŸ‡¨ğŸ‡¾", "IS": "ğŸ‡®ğŸ‡¸", "MX": "ğŸ‡²ğŸ‡½", "AR": "ğŸ‡¦ğŸ‡·", "CL": "ğŸ‡¨ğŸ‡±", "CO": "ğŸ‡¨ğŸ‡´", "PE": "ğŸ‡µğŸ‡ª", "VE": "ğŸ‡»ğŸ‡ª",
	"EC": "ğŸ‡ªğŸ‡¨", "UY": "ğŸ‡ºğŸ‡¾", "PY": "ğŸ‡µğŸ‡¾", "BO": "ğŸ‡§ğŸ‡´", "CR": "ğŸ‡¨ğŸ‡·", "PA": "ğŸ‡µğŸ‡¦", "GT": "ğŸ‡¬ğŸ‡¹", "HN": "ğŸ‡­ğŸ‡³",
	"SV": "ğŸ‡¸ğŸ‡»", "NI": "ğŸ‡³ğŸ‡®", "BZ": "ğŸ‡§ğŸ‡¿", "JM": "ğŸ‡¯ğŸ‡²", "TT": "ğŸ‡¹ğŸ‡¹", "BB": "ğŸ‡§ğŸ‡§", "GD": "ğŸ‡¬ğŸ‡©", "LC": "ğŸ‡±ğŸ‡¨",
	"VC": "ğŸ‡»ğŸ‡¨", "AG": "ğŸ‡¦ğŸ‡¬", "DM": "ğŸ‡©ğŸ‡²", "KN": "ğŸ‡°ğŸ‡³", "BS": "ğŸ‡§ğŸ‡¸", "CU": "ğŸ‡¨ğŸ‡º", "DO": "ğŸ‡©ğŸ‡´", "HT": "ğŸ‡­ğŸ‡¹",
	"PR": "ğŸ‡µğŸ‡·", "VI": "ğŸ‡»ğŸ‡®", "GU": "ğŸ‡¬ğŸ‡º", "AS": "ğŸ‡¦ğŸ‡¸", "MP": "ğŸ‡²ğŸ‡µ", "PW": "ğŸ‡µğŸ‡¼", "FM": "ğŸ‡«ğŸ‡²", "MH": "ğŸ‡²ğŸ‡­",
	"KI": "ğŸ‡°ğŸ‡®", "TV": "ğŸ‡¹ğŸ‡»", "NR": "ğŸ‡³ğŸ‡·", "WS": "ğŸ‡¼ğŸ‡¸", "TO": "ğŸ‡¹ğŸ‡´", "FJ": "ğŸ‡«ğŸ‡¯", "VU": "ğŸ‡»ğŸ‡º", "SB": "ğŸ‡¸ğŸ‡§",
	"PG": "ğŸ‡µğŸ‡¬", "NC": "ğŸ‡³ğŸ‡¨", "PF": "ğŸ‡µğŸ‡«", "WF": "ğŸ‡¼ğŸ‡«", "CK": "ğŸ‡¨ğŸ‡°", "NU": "ğŸ‡³ğŸ‡º", "TK": "ğŸ‡¹ğŸ‡°", "SC": "ğŸ‡¸ğŸ‡¨",
}

// DefaultNameTemplate is the built-in format when -rename-template is not set.
const DefaultNameTemplate = `{{.Flag}} {{.CountryCode}} {{.Index}} | {{.Direction}} {{.Speed}}MB/s`

// NodeNameData is the data passed to the rename template.
type NodeNameData struct {
	Flag               string // country flag emoji
	CountryCode        string // e.g. US, HK
	Index              string // padded number, e.g. 001
	Direction          string // â¬‡ï¸ or â¬†ï¸
	Speed              string // main speed in MB/s (e.g. 12.34)
	DownloadSpeedMBps  string // download MB/s
	UploadSpeedMBps    string // upload MB/s
}

// GenerateNodeNameFromTemplate renders name from a text/template. Placeholders:
// {{.Flag}}, {{.CountryCode}}, {{.Index}}, {{.Direction}}, {{.Speed}}, {{.DownloadSpeedMBps}}, {{.UploadSpeedMBps}}.
// If template is empty, DefaultNameTemplate is used. On execute error, falls back to default format.
func GenerateNodeNameFromTemplate(tmpl string, countryCode string, downloadSpeed, uploadSpeed float64, nameCount map[string]int) (string, error) {
	if tmpl == "" {
		tmpl = DefaultNameTemplate
	}
	t, err := template.New("name").Parse(tmpl)
	if err != nil {
		return "", err
	}
	data := buildNodeNameData(countryCode, downloadSpeed, uploadSpeed, nameCount)
	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		// fallback to default format so caller does not double-increment nameCount
		return fmt.Sprintf("%s %s %s | %s %sMB/s", data.Flag, data.CountryCode, data.Index, data.Direction, data.Speed), nil
	}
	return buf.String(), nil
}

func buildNodeNameData(countryCode string, downloadSpeed, uploadSpeed float64, nameCount map[string]int) NodeNameData {
	flag, exists := countryFlags[strings.ToUpper(countryCode)]
	if !exists {
		flag = "ğŸ³ï¸"
	}
	upperCountryCode := strings.ToUpper(countryCode)
	speed := downloadSpeed
	direction := "â¬‡ï¸"
	if downloadSpeed <= 0 {
		speed = uploadSpeed
		direction = "â¬†ï¸"
	}
	speedMBps := speed / (1024 * 1024)
	count := nameCount[upperCountryCode] + 1
	nameCount[upperCountryCode] = count
	dlMBps := downloadSpeed / (1024 * 1024)
	ulMBps := uploadSpeed / (1024 * 1024)
	return NodeNameData{
		Flag:              flag,
		CountryCode:       upperCountryCode,
		Index:             fmt.Sprintf("%03d", count),
		Direction:         direction,
		Speed:             fmt.Sprintf("%.2f", speedMBps),
		DownloadSpeedMBps: fmt.Sprintf("%.2f", dlMBps),
		UploadSpeedMBps:   fmt.Sprintf("%.2f", ulMBps),
	}
}

func GenerateNodeName(countryCode string, downloadSpeed float64, uploadSpeed float64, nameCount map[string]int) string {
	name, _ := GenerateNodeNameFromTemplate("", countryCode, downloadSpeed, uploadSpeed, nameCount)
	return name
}
